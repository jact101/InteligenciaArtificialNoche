<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inteligencia Artificial, Ciberseguridad y Algoritmos de Búsqueda</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1 {
            color: #2c3e50;
        }
        h2 {
            color: #34495e;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border: 1px solid #ccc;
            overflow: auto;
        }
    </style>
</head>
<body>
    <h1>Clase 15 de Agosto de 2024</h1>
    <p>
        En el webinar sobre Ciberseguridad, Inteligencia Artificial y Computación en la Nube, se destacó la importancia de la ciberseguridad 
        para prevenir ataques de malware y phishing, los cuales buscan robar información sin el consentimiento de las personas.
    </p>
    <p>
        Además, se resaltó el uso de la IA y la computación en la nube como herramientas para reducir costos de administración 
        y agilizar la gestión de procesos como transacciones, retiros y transferencias de dinero. Estas tecnologías permiten 
        garantizar la seguridad de las personas y cómo manejan su dinero.
    </p>
    <p>
        Es fundamental considerar si realmente deseamos otorgar permisos a páginas o plataformas para el tratamiento de nuestros datos personales. 
        Esta regulación está definida en la Ley de Protección de Datos Personales (Ley 1581 de 2012), que reconoce y protege el derecho de todas las personas 
        a conocer, actualizar y rectificar la información recopilada sobre ellas, la cual se almacena en bases de datos o archivos que pueden ser tratados 
        por entidades públicas o privadas.
    </p>

    <h1>¿Qué es la Inteligencia Artificial?</h1>
    <p>
        La inteligencia artificial (IA) es un amplio campo de la informática centrado en la creación de sistemas y tecnologías capaces de realizar tareas 
        que normalmente requieren inteligencia humana, como la generación de código para aplicaciones. Estas tareas incluyen:
    </p>
    <ul>
        <li>Reconocimiento de voz</li>
        <li>Aprendizaje automático</li>
        <li>Toma de decisiones</li>
        <li>Resolución de problemas</li>
        <li>Percepción visual</li>
        <li>Traducción de idiomas</li>
        <li>Y más</li>
    </ul>
    <p>
        La IA se divide en dos categorías principales:
    </p>
    <ul>
        <li>
            <strong>IA estrecha o IA débil:</strong> Es un tipo de inteligencia artificial diseñada para realizar una tarea específica. 
            Ejemplos de IA débil incluyen asistentes virtuales como Siri o Alexa, motores de recomendación en plataformas 
            como Netflix o Amazon, y sistemas de reconocimiento facial. Estas IA no tienen conciencia ni comprensión general; 
            están programadas para funciones concretas.
        </li>
        <li>
            <strong>IA general o IA fuerte:</strong> Se refiere a una inteligencia artificial con una capacidad cognitiva similar a la de un ser humano, 
            es decir, que puede realizar cualquier tarea intelectual que un humano puede hacer, como generar y reciclar código de aplicaciones. 
            La IA fuerte aún no existe, pero es un objetivo a largo plazo en la investigación en IA.
        </li>
    </ul>

    <h1>Clase 22 de Agosto de 2024</h1>

    <h2>Origen de la Inteligencia Artificial</h2>
    <p>
        El origen de la inteligencia artificial se remonta a los años 30, con el trabajo de Alan Turing en la máquina Enigma, 
        capaz de descifrar los mensajes secretos de los nazis durante la Segunda Guerra Mundial. Durante este tiempo, 
        Turing desarrolló algoritmos utilizados en la máquina Enigma, demostrando su capacidad para predecir y evaluar 
        los mensajes enviados por el ejército nazi.
    </p>

    <h2>Pensamiento Filosófico de Turing</h2>
    <p>
        Turing creía que “si una máquina tiene un comportamiento inteligente en todos los aspectos, entonces es inteligente”. 
        Se dedicó a demostrar la eficiencia de las máquinas, lo que lo llevó a inventar el famoso Test de Turing, 
        un método para comprobar que ciertas tecnologías pueden dar respuestas similares a las de un ser humano, e incluso ser indistinguibles. 
        Turing es considerado el padre de la Inteligencia Artificial.
    </p>

    <h2>Inteligencia Artificial Moderna</h2>
    <p>
        Aunque Alan Turing sentó bases sólidas en el estudio de la IA, no fue hasta 1956 que John McCarthy, Marvin Minsky y Claude Shannon 
        popularizaron el término "Inteligencia Artificial" en la conferencia "Dartmouth Summer Research Project on Artificial Intelligence". 
        A partir de ese momento, se reconoció que las IA:
    </p>
    <ul>
        <li>Pueden tener creencias o intenciones dentro de sus actitudes mentales.</li>
        <li>Tienen la capacidad de aprender.</li>
        <li>Pueden resolver problemas desde distintos niveles de comprensión.</li>
        <li>Son capaces de analizar situaciones complejas y darles un sentido lógico.</li>
        <li>Conocen sus limitaciones.</li>
        <li>Pueden ser originales, percibir cosas y modelar su realidad.</li>
        <li>Utilizan lenguajes y símbolos.</li>
    </ul>

    <h2>La IA en la Actualidad</h2>
    <p>
        Hoy en día, las Inteligencias Artificiales se utilizan en diversas herramientas para el análisis de Big Data y forman parte de sectores esenciales 
        como la salud, tecnología, turismo, movilidad, seguridad y economía. Se estima que su implementación generará ganancias de hasta 300 mil millones de dólares anuales a partir de 2024.
    </p>

    <h1>Fundamentos Filosóficos de la Inteligencia Artificial</h1>
    <p>
        Los principales enfoques filosóficos que influyen en la IA incluyen:
    </p>
    <ul>
        <li>Idealismo</li>
        <li>Materialismo</li>
        <li>Empirismo</li>
        <li>Existencialismo</li>
        <li>Pragmatismo</li>
        <li>Humanismo</li>
        <li>Racionalismo</li>
    </ul>

    <h1>Modelo de Red Neuronal con TensorFlow</h1>
    <pre>
import tensorflow as tf  # importa la biblioteca TensorFlow y la asigna al alias 'tf'.

import numpy as np  # importa la biblioteca NumPy y la asigna al alias 'np'.

celsius = np.array([-40, -10, 0, 8, 15, 22, 38], dtype=float) # crea un array de la librería NumPy.

fahrenheit = np.array([-40, 14, 32, 46, 59, 72, 100], dtype=float) # crea un array de NumPy.

oculta1 = tf.keras.layers.Dense(units=3, input_shape=[1]) # crea una capa oculta con 3 neuronas.

oculta2 = tf.keras.layers.Dense(units=3) # crea una segunda capa oculta con 3 neuronas.

salida = tf.keras.layers.Dense(units=1) # capa de salida.

modelo = tf.keras.Sequential([oculta1, oculta2, salida]) # crea un modelo secuencial.

modelo.compile( # compila el modelo.
    optimizer=tf.keras.optimizers.Adam(0.1), # optimizador Adam con tasa de aprendizaje.
    loss='mean_squared_error' # función de pérdida.
)

print("Comenzando entrenamiento...") # mensaje de inicio de entrenamiento
historial = modelo.fit(celsius, fahrenheit, epochs=1000, verbose=False) # entrena el modelo.
print("Modelo entrenado!") # mensaje de finalización del modelo

import matplotlib.pyplot as plt # importa la biblioteca Matplotlib.
plt.xlabel("# Epoca") # etiqueta para el eje X.
plt.ylabel("Magnitud de pérdida") # etiqueta para el eje Y.
plt.plot(historial.history["loss"]) # grafica la pérdida.

print("Hagamos una predicción!") # mensaje de predicción
resultado = modelo.predict([100.0]) # realiza una predicción.
print("El resultado es " + str(resultado) + " fahrenheit!") # imprime el resultado.

print("Variables internas del modelo") # imprime variables internas del modelo
print(oculta1.get_weights()) # muestra los pesos de la capa oculta 1
print(oculta2.get_weights()) # muestra los pesos de la capa oculta 2
print(salida.get_weights()) # muestra los pesos de la capa de salida
    </pre>

    <h1>Enlace de archivo drive punto 3 y 5 del parcial</h1>
    <p>https://drive.google.com/file/d/1DxIkIT-kT1YLvHxayMV4Zb7A8PXBzP09/view?usp=sharing</p>
    
    <h1>Algoritmo de búsqueda</h1>
    <p>Es un conjunto de instrucciones diseñadas para localizar un elemento dentro de una colección. Existen varios tipos de algoritmos de búsqueda, entre los que destacan:</p>
    <ul>
        <li><strong>Búsqueda lineal:</strong> Revisa cada elemento de la lista uno por uno hasta encontrar el objetivo. Es simple, pero poco eficiente en listas grandes.</li>
        <li><strong>Búsqueda binaria:</strong> Solo se aplica a listas ordenadas. Divide la lista en mitades, reduciendo el espacio de búsqueda. Es mucho más eficiente que la búsqueda lineal.</li>
        <li><strong>Búsqueda por interpolación:</strong> Mejor para listas con valores uniformemente distribuidos. Usa la posición del valor a buscar para determinar dónde continuar la búsqueda.</li>
    </ul>

    <h2>Ejemplo de Búsqueda Binaria</h2>
    <pre>
def busqueda_binaria(lista, objetivo):
    bajo = 0  # índice más bajo
    alto = len(lista) - 1  # índice más alto

    while bajo <= alto:  # mientras haya elementos
        medio = (bajo + alto) // 2  # índice medio
        if lista[medio] == objetivo:  # si el medio es el objetivo
            return medio  # retorna el índice
        elif lista[medio] < objetivo:  # si el medio es menor que el objetivo
            bajo = medio + 1  # ajusta el índice más bajo
        else:
            alto = medio - 1  # ajusta el índice más alto
    return -1  # si no se encuentra el objetivo
    </pre>

    <h2>Uso de la Búsqueda Binaria</h2>
    <pre>
        numeros = [1, 2, 3, 4, 5, 6, 7, 8, 9]  # lista ordenada de números
        resultado = busqueda_binaria(numeros, 5)  # busca el número 5
        print("El índice de 5 es:", resultado)  # imprime el índice encontrado
    </pre>

    <h2>Conclusiones</h2>
    <p>
        En esta clase, exploramos cómo la inteligencia artificial ha transformado la forma en que interactuamos con la tecnología, 
        así como los principios fundamentales de la ciberseguridad y la importancia de proteger nuestros datos personales. 
        También se discutió el papel de los algoritmos de búsqueda en la optimización de procesos y la toma de decisiones.
    </p>

    <h1>PARCIAL #2 </h1>
    <h2>Punto 5 logic.py</h2>
    <pre>
        import itertools
    
        class Sentence():
        """
        Clase base para representar una oración lógica.
        """
    
        def evaluate(self, model):
            """
            Evalúa la oración lógica utilizando un modelo.
            En este caso, es un método abstracto que será implementado en clases derivadas.
            """
            raise Exception("nada que evaluar")  # Lanza una excepción si se llama a este método sin implementación.
    
        def formula(self):
            """
            Devuelve una representación de la fórmula lógica en forma de cadena de texto.
            """
            return ""  # Por defecto, retorna una cadena vacía.
    
        def symbols(self):
            """
            Devuelve un conjunto de todos los símbolos presentes en la oración lógica.
            """
            return set()  # Por defecto, retorna un conjunto vacío.
    
        @classmethod
        def validate(cls, sentence):
            """
            Valida si un objeto es una instancia de la clase Sentence.
            """
            if not isinstance(sentence, Sentence):
                raise TypeError("debe ser una oración lógica")  # Lanza un error si no es una instancia de Sentence.
    
        @classmethod
        def parenthesize(cls, s):
            """
            Coloca paréntesis en una expresión si no los tiene ya.
            """
            def balanced(s):
                """
                Verifica si una cadena tiene paréntesis balanceados.
                """
                count = 0
                for c in s:
                    if c == "(":
                        count += 1
                    elif c == ")":
                        if count <= 0:
                            return False  # Retorna False si hay un paréntesis de cierre sin su correspondiente apertura.
                        count -= 1
                return count == 0  # Retorna True si los paréntesis están balanceados.
    
            # Verifica si la cadena necesita paréntesis.
            if not len(s) or s.isalpha() or (
                s[0] == "(" and s[-1] == ")" and balanced(s[1:-1])
            ):
                return s  # Si ya tiene paréntesis o es una letra, retorna la cadena tal cual.
            else:
                return f"({s})"  # De lo contrario, agrega paréntesis.
    
    class Symbol(Sentence):
        """
        Representa un símbolo lógico.
        """
    
        def __init__(self, name):
            self.name = name  # Inicializa el símbolo con un nombre.
    
        def __eq__(self, other):
            return isinstance(other, Symbol) and self.name == other.name  # Compara si dos símbolos son iguales.
    
        def __hash__(self):
            return hash(("symbol", self.name))  # Retorna un hash del símbolo.
    
        def __repr__(self):
            return self.name  # Representa el símbolo como su nombre.
    
        def evaluate(self, model):
            """
            Evalúa el valor del símbolo en un modelo dado.
            """
            try:
                return bool(model[self.name])  # Retorna el valor booleano del símbolo en el modelo.
            except KeyError:
                raise EvaluationException(f"variable {self.name} no está en el modelo")  # Lanza un error si el símbolo no está en el modelo.
    
        def formula(self):
            return self.name  # Retorna el nombre del símbolo como fórmula.
    
        def symbols(self):
            """
            Devuelve el conjunto que contiene solo este símbolo.
            """
            return {self.name}  # Retorna un conjunto con el símbolo.
    
    class Not(Sentence):
        """
        Representa una negación lógica.
        """
        def __init__(self, operand):
            Sentence.validate(operand)  # Valida el operando.
            self.operand = operand  # Inicializa la negación con un operando.
    
        def __eq__(self, other):
            return isinstance(other, Not) and self.operand == other.operand  # Compara si dos negaciones son iguales.
    
        def __hash__(self):
            return hash(("not", hash(self.operand)))  # Retorna un hash de la negación.
    
        def __repr__(self):
            return f"Not({self.operand})"  # Representa la negación como "Not(operando)".
    
        def evaluate(self, model):
            """
            Evalúa la negación, invirtiendo el valor del operando.
            """
            return not self.operand.evaluate(model)  # Retorna el valor invertido del operando.
    
        def formula(self):
            return "¬" + Sentence.parenthesize(self.operand.formula())  # Retorna la fórmula de la negación.
    
        def symbols(self):
            return self.operand.symbols()  # Retorna los símbolos del operando.
    
    class And(Sentence):
        """
        Representa una conjunción lógica (Y).
        """
        def __init__(self, *conjuncts):
            for conjunct in conjuncts:
                Sentence.validate(conjunct)  # Valida cada conjunción.
            self.conjuncts = list(conjuncts)  # Inicializa la conjunción con una lista de operandos.
    
        def __eq__(self, other):
            return isinstance(other, And) and self.conjuncts == other.conjuncts  # Compara si dos conjunciones son iguales.
    
        def __hash__(self):
            return hash(
                ("and", tuple(hash(conjunct) for conjunct in self.conjuncts))  # Retorna un hash de la conjunción.
            )
    
        def __repr__(self):
            conjunctions = ", ".join(
                [str(conjunct) for conjunct in self.conjuncts]  # Representa cada conjunción.
            )
            return f"And({conjunctions})"  # Retorna una representación de la conjunción.
    
        def add(self, conjunct):
            """
            Añade un nuevo conjuncto a la lista.
            """
            Sentence.validate(conjunct)  # Valida el nuevo conjuncto.
            self.conjuncts.append(conjunct)  # Agrega el conjuncto a la lista.
    
        def evaluate(self, model):
            """
            Evalúa si todas las conjunciones son verdaderas.
            """
            return all(conjunct.evaluate(model) for conjunct in self.conjuncts)  # Retorna True si todas las conjunciones son verdaderas.
    
        def formula(self):
            """
            Devuelve la fórmula de la conjunción.
            """
            if len(self.conjuncts) == 1:
                return self.conjuncts[0].formula()  # Si hay solo una conjunción, retorna su fórmula.
            return " ∧ ".join([Sentence.parenthesize(conjunct.formula())
                               for conjunct in self.conjuncts])  # Une las fórmulas de las conjunciones con "∧".
    
        def symbols(self):
            return set.union(*[conjunct.symbols() for conjunct in self.conjuncts])  # Retorna la unión de todos los símbolos en las conjunciones.
    
    class Or(Sentence):
        """
        Representa una disyunción lógica (O).
        """
        def __init__(self, *disjuncts):
            for disjunct in disjuncts:
                Sentence.validate(disjunct)  # Valida cada disyunción.
            self.disjuncts = list(disjuncts)  # Inicializa la disyunción con una lista de operandos.
    
        def __eq__(self, other):
            return isinstance(other, Or) and self.disjuncts == other.disjuncts  # Compara si dos disyunciones son iguales.
    
        def __hash__(self):
            return hash(
                ("or", tuple(hash(disjunct) for disjunct in self.disjuncts))  # Retorna un hash de la disyunción.
            )
    
        def __repr__(self):
            disjuncts = ", ".join([str(disjunct) for disjunct in self.disjuncts])  # Representa cada disyunción.
            return f"Or({disjuncts})"  # Retorna una representación de la disyunción.
    
        def evaluate(self, model):
            """
            Evalúa si al menos una de las disyunciones es verdadera.
            """
            return any(disjunct.evaluate(model) for disjunct in self.disjuncts)  # Retorna True si al menos una disyunción es verdadera.
    
        def formula(self):
            """
            Devuelve la fórmula de la disyunción.
            """
            if len(self.disjuncts) == 1:
                return self.disjuncts[0].formula()  # Si hay solo una disyunción, retorna su fórmula.
            return " ∨ ".join([Sentence.parenthesize(disjunct.formula())
                                for disjunct in self.disjuncts])  # Une las fórmulas de las disyunciones con "∨".
    
        def symbols(self):
            return set.union(*[disjunct.symbols() for disjunct in self.disjuncts])  # Retorna la unión de todos los símbolos en las disyunciones.
    
    class Implication(Sentence):
        """
        Representa una implicación lógica (si... entonces...).
        """
        def __init__(self, antecedent, consequent):
            Sentence.validate(antecedent)  # Valida el antecedente.
            Sentence.validate(consequent)  # Valida el consecuente.
            self.antecedent = antecedent  # Inicializa el antecedente.
            self.consequent = consequent  # Inicializa el consecuente.
    
        def __eq__(self, other):
            return isinstance(other, Implication) and \
                   self.antecedent == other.antecedent and \
                   self.consequent == other.consequent  # Compara si dos implicaciones son iguales.
    
        def __hash__(self):
            return hash(("implication", hash(self.antecedent), hash(self.consequent)))  # Retorna un hash de la implicación.
    
        def __repr__(self):
            return f"Implication({self.antecedent}, {self.consequent})"  # Representa la implicación como "Implication(antecedente, consecuente)".
    
        def evaluate(self, model):
            """
            Evalúa la implicación.
            """
            return not self.antecedent.evaluate(model) or self.consequent.evaluate(model)  # Evalúa la implicación.
    
        def formula(self):
            return f"({self.antecedent.formula()} → {self.consequent.formula()})"  # Retorna la fórmula de la implicación.
    
        def symbols(self):
            return self.antecedent.symbols().union(self.consequent.symbols())  # Retorna la unión de los símbolos en antecedente y consecuente.
    
    class EvaluationException(Exception):
        """
        Excepción lanzada para errores en la evaluación de expresiones lógicas.
        """
        pass
    
    def model_check(knowledge, conclusion):
        """
        Realiza la verificación de un modelo dado un conjunto de conocimientos y una conclusión.
        """
        symbols = set()  # Conjunto para almacenar los símbolos únicos.
    
        # Reúne todos los símbolos presentes en los conocimientos y la conclusión.
        for sentence in knowledge:
            symbols = symbols.union(sentence.symbols())
        symbols = symbols.union(conclusion.symbols())
    
        # Genera todos los modelos posibles.
        for truth_assignment in itertools.product([True, False], repeat=len(symbols)):
            model = dict(zip(symbols, truth_assignment))  # Crea un modelo asignando valores de verdad a los símbolos.
            
            # Evalúa si todos los conocimientos son verdaderos en el modelo.
            if all(sentence.evaluate(model) for sentence in knowledge):
                # Si la conclusión es falsa, significa que el conocimiento no implica la conclusión.
                if not conclusion.evaluate(model):
                    return False  # Retorna False si hay un modelo que hace los conocimientos verdaderos y la conclusión falsa.
    
        return True  # Retorna True si todos los modelos cumplen con los conocimientos y la conclusión.
    </pre>

    <h2>Punto 6 estudianteunimayor.py</h2>
    <pre>
        rain = False         # True si llueve, False si no
        bbc = False          # True si los estudiantes visitaron BBC
        unimayor = True      # True si los estudiantes visitaron Unimayor
        
        # Conocimiento:
        # Si no llueve, los estudiantes visitan BBC
        if not rain:
            bbc = True
        
        # Los estudiantes visitaron BBC o Unimayor pero no ambos (XOR)
        bbc_unimayor = (bbc or unimayor) and not (bbc and unimayor)
        
        # Los estudiantes visitaron Unimayor
        unimayor = True  # Afirmación directa
        
        # Inferencia sobre BBC y el clima
        print("¿Los estudiantes visitaron BBC?", bbc)
        print("¿Llovió?", rain)
    </pre>

    <h2> CODIGO DEL VIDEO ALGORITMO DE APRENDIZAJE SUPERVISADO PYTHON  </h2>
    <pre>
        # Importamos las bibliotecas necesarias
        import numpy as np
        import matplotlib.pyplot as plt
        from sklearn.model_selection import train_test_split
        from sklearn.linear_model import LinearRegression
        from sklearn.metrics import mean_squared_error, r2_score
        
        # Generar datos sintéticos
        np.random.seed(42)  # Para reproducibilidad
        X = 2 * np.random.rand(100, 1)  # 100 puntos aleatorios entre 0 y 2
        y = 4 + 3 * X + np.random.randn(100, 1)  # y = 4 + 3x + ruido
        
        # Dividir el conjunto de datos en entrenamiento y prueba
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
        
        # Crear el modelo de regresión lineal
        model = LinearRegression()
        
        # Entrenar el modelo con los datos de entrenamiento
        model.fit(X_train, y_train)
        
        # Predecir los valores en el conjunto de prueba
        y_pred = model.predict(X_test)
        
        # Evaluar el modelo
        mse = mean_squared_error(y_test, y_pred)
        r2 = r2_score(y_test, y_pred)
        
        # Imprimir resultados
        print("Coeficiente de la regresión (pendiente):", model.coef_[0][0])
        print("Intercepción (ordenada en el origen):", model.intercept_[0])
        print("Error cuadrático medio (MSE):", mse)
        print("Coeficiente de determinación (R²):", r2)
        
        # Visualizar resultados
        plt.scatter(X_test, y_test, color="blue", label="Datos reales")
        plt.plot(X_test, y_pred, color="red", label="Predicción")
        plt.title("Regresión Lineal")
        plt.xlabel("Variable independiente (X)")
        plt.ylabel("Variable dependiente (y)")
        plt.legend()
        plt.show()
    </pre>

</body>
</html>
